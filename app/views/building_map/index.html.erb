<div class="offcanvas offcanvas-end" tabindex="-1" id="offcanvas" data-bs-keyboard="false" data-bs-backdrop="false">
  <div class="offcanvas-header">
    <h5 class="offcanvas-title d-none d-sm-block" id="offcanvas">Navigation</h5>
    <button type="button" class="btn-close text-reset" data-bs-dismiss="offcanvas" aria-label="Close"></button>
  </div>
  <div class="offcanvas-body px-0">
    <div class="accordion mb-2 accordion-flush" id="routingInput">
      <div class="accordion-item">
        <h2 class="accordion-header" id="headingOne">
          <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                  data-bs-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
            <i class="fas fa-directions directions-icon"></i>
          </button>
        </h2>
        <div id="collapseOne" class="accordion-collapse collapse show" aria-labelledby="headingOne"
             data-bs-parent="#routingInput">
          <div class="accordion-body">
            <form class="row gy-2 gx-3 align-items-center" autocomplete="off" id="navigation_form" method="GET" action="/building_map">
              <div class="col-auto">
                <div class="input-group">
                  <div class="input-group-text"><i class="fas fa-map-marker-alt route-start-icon"></i></div>
                  <input name="start" type="text" class="form-control" list="startOptions" id="start_input"
                         placeholder="From" onchange="request_location()">
                </div>
              </div>
              <div class="col-auto">
                <div class="input-group">
                  <div class="input-group-text"><i class="fas fa-map-marker-alt route-end-icon"></i></div>
                  <input name="dest" type="text" class="form-control" list="destOptions" id="dest_input"
                         placeholder="To">
                </div>
              </div>
              <div class="col-auto">
                <button type="submit" class="btn btn-primary">Go</button>
              </div>
            </form>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<datalist id="startOptions">
  <option><%= BuildingMapController::YOUR_LOCATION_MAGIC_STRING %></option>
  <%= Places::DESTINATIONS.each do |dest, coords| %>
    <option>
      <%= dest %>
    </option>
  <% end %>
</datalist>
<datalist id="destOptions">
  <%= Places::DESTINATIONS.each do |dest, coords| %>
    <option>
      <%= dest %>
    </option>
  <% end %>
</datalist>

<div class="container-fluid">
  <%= map(
        center: BuildingMapHelper.leaflet_center(@start),
        polygons: BuildingMapHelper.leaflet_polygons,
        polylines: BuildingMapHelper.leaflet_polylines(@route),
        markers: BuildingMapHelper.leaflet_markers(@route, @target))
  %>
</div>

<script>
    let currentLocation;

    function validate_place_input(inputId, optionsId) {
        const input = document.getElementById(inputId);
        const options = document.getElementById(optionsId).options;
        return Array.from(options).some(o => o.value === input.value);
    }

    const start_input_field = document.getElementById("start_input");
    start_input_field.addEventListener("change", () => {
        if (validate_place_input("start_input", "startOptions")) {
            start_input_field.setCustomValidity("");
        } else {
            start_input_field.setCustomValidity("Please select a valid starting place.");
        }
    });
    start_input_field.dispatchEvent(new Event("change"));

    const dest_input_field = document.getElementById("dest_input");
    dest_input_field.addEventListener("change", () => {
        if (validate_place_input("dest_input", "destOptions")) {
            dest_input_field.setCustomValidity("");
        } else {
            dest_input_field.setCustomValidity("Please select a valid destination place.");
        }
    });
    dest_input_field.dispatchEvent(new Event("change"));

    function request_location() {
        if (start_input_field.value !== "<%= BuildingMapController::YOUR_LOCATION_MAGIC_STRING %>") return;
        navigator.geolocation.getCurrentPosition(
            (pos) => {
                currentLocation = String(pos.coords.latitude) + "," + String(pos.coords.longitude);
                start_input_field.setCustomValidity("");
            },
            (error) => {
                console.warn(`ERROR(${error.code}): ${error.message}`);
                if (error.code === GeolocationPositionError.PERMISSION_DENIED) {
                    start_input_field.setCustomValidity("You have to grant your browser the permission to access your location if you want to use this feature.")
                } else {
                    start_input_field.setCustomValidity("Your browser could not determine your position. Please choose a different starting place.")
                }
            }
        );
    }

    document.getElementById("navigation_form").addEventListener("submit", () => {
        if (start_input_field.value === "<%= BuildingMapController::YOUR_LOCATION_MAGIC_STRING %>") {
            start_input_field.value = currentLocation;
        }
    });
</script>

<script>
  function addIndoorLabel(feature, layer) {
    const point = polylabel([layer._latlngs[0].map(point => {return [point.lat, point.lng]})], 0.000001, true);
    L.circleMarker({lat: point[0], lng: point[1]}, {opacity: 0, radius: 0}).bindTooltip(
      feature.properties.name,
      {
          permanent: true,
          direction:'center',
          className: 'indoor-label',
      }
    ).addTo(map);
  }

  const layerControl = L.control.layers({}).addTo(map);

  function loadGeoJsonFile(filename) {
    fetch(filename)
    .then(response => response.json())
    .then(geojsonFeatureCollection => {
      // Manually add indoor labels to map
      const rooms = L.geoJSON(geojsonFeatureCollection, { filter: (f => {return f.geometry.type != "Point"}) }).addTo(map);
      const group = L.layerGroup(rooms);
      rooms.eachLayer((layer)=>{  
        const point = polylabel([layer._latlngs[0].map(point => {return [point.lat, point.lng]})], 0.000001, true);
        L.circleMarker({lat: point[0], lng: point[1]}, {opacity: 0, radius: 0}).bindTooltip(
          feature.properties.name,
          {
            permanent: true,
            direction:'center',
            className: 'indoor-label',
          }
        ).addTo(map).addTo(group);
        //console.log(layer._latlngs[0].map(point => {return [point.lat, point.lng]}));
        //console.log(polylabel([layer._latlngs[0].map(point => {return [point.lat, point.lng]})], 1.0));
      });
      recalculateTooltipVisibility()
      layerControl.addBaseLayer(rooms);
    })
  }

  loadGeoJsonFile('assets/ABC-Building-0.geojson');
  loadGeoJsonFile('assets/ABC-Building-1.geojson');
  function recalculateTooltipVisibility() {
    const zoomLevel = map.getZoom()
    map.eachLayer(layer => {
      if (layer.getTooltip()) {
        if (zoomLevel >= 19 /* nearest zoom */) {
          //layer.openTooltip()
          //layer.getTooltip().update();
        } else {
          //layer.closeTooltip()
        }
      }
    })
  }
  map.on('zoomend', recalculateTooltipVisibility);
</script>
